




## The Application Shell

Set up your environment

In this part of the tutorial, you'll do the following:

Set up your environment.
Create a new workspace and initial app project.
Serve the application.
Make changes to the application.

### Set up your environment.

To set up your development environment, follow these instructions in Getting Started:

Prerequisites  (link var)
Install the Angular CLI (link var)

Create a new workspace and an initial application

You develop apps in the context of an Angular workspace. A workspace contains the files for one or more projects. A project is the set of files that comprise an app, a library, or end-to-end (e2e) tests. For this tutorial, you will create a new workspace.

```
ng new angular-tour-of-heroes
```

The Angular CLI installs the necessary Angular npm packages and other dependencies. This can take a few minutes.
It also creates the following workspace and starter project files:

A new workspace, with a root folder named angular-tour-of-heroes.
An initial skeleton app project, also called angular-tour-of-heroes (in the src subfolder).
An end-to-end test project (in the e2e subfolder).
Related configuration files.

The initial app project contains a simple Welcome app, ready to run.

### Serve the application

Go to the workspace directory and launch the application.
cd angular-tour-of-heroes

```
ng serve --open
```

The ng serve command builds the app, starts the development server, watches the source files, and rebuilds the app as you make changes to those files.

The --open flag  opens a browser to http://localhost:4200/
You should see the app running in your browser.

Angular components

The page you see is the application shell.
The shell is controlled by an Angular component named AppComponent.
Components are the fundamental building blocks of Angular applications.
They display data on the screen, listen for user input, and take action based on that input.

Add application styles

Most apps strive for a consistent look across the application.
The CLI generated an empty styles.css for this purpose.
Put your application-wide styles there.

Where is styles.css file

???





## The Hero Editor

Next you will create a new component to display hero information and place that component in the application shell. ( uygulama kabugu / ortamı )

Create the heroes component
Using the Angular CLI, generate a new component named heroes.


ng generate component heroes

The CLI creates a new folder, src/app/heroes/, and generates the three files of the  HeroesComponent.

The HeroesComponent class file is as follows:

app/heroes/heroes.component.ts (initial version) 

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}

You always import the Component symbol from the Angular core library and annotate the component class with @Component.

@Component is a decorator function that specifies the Angular metadata for the component.
The CLI generated three metadata properties:

selector— the component's CSS element selector
templateUrl— the location of the component's template file.
styleUrls— the location of the component's private CSS styles.

The CSS element selector, 'app-heroes', matches the name of the HTML element that identifies this component within a parent component's template.

The ngOnInit is a lifecycle hook. Angular calls ngOnInit shortly after creating a component. It's a good place to put initialization logic.

Always export the component class so you can import it elsewhere ... like in the AppModule.

Add a hero property

Add a hero property to the HeroesComponent for a hero named "Windstorm."


hero = 'Windstorm';

Show the hero

Open the heroes.component.html template file.
Delete the default text generated by the Angular CLI and replace it with a data binding to the new hero property.


{{hero}}

Show the HeroesComponent view

To display the HeroesComponent, you must add it to the template of the shell AppComponent.
Remember that app-heroes is the element selector
for the HeroesComponent.
So add an <app-heroes> element to the AppComponent template file, just below the title.


<h1>{{title}}</h1>
<app-heroes></app-heroes>

Create a Hero class
Create a Hero class in its own file in the src/app folder.
Give it id and name properties.


export class Hero {
  id: number;
  name: string;
}

Return to the HeroesComponent class and import the Hero class.
Refactor the component's hero property to be of type Hero.
Initialize it with an id of 1 and the name Windstorm.
The revised HeroesComponent class file should look like this:


import { Component, OnInit } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {
  hero: Hero = {
    id: 1,
    name: 'Windstorm'
  };

  constructor() { }

  ngOnInit() {
  }

}

The page no longer displays properly because you changed the hero from a string to an object.
Show the hero object
Update the binding in the template to announce the hero's name
and show both id and name in a details layout like this:


<h2>{{hero.name}} Details</h2>
<div><span>id: </span>{{hero.id}}</div>
<div><span>name: </span>{{hero.name}}</div>

Format with the UppercasePipe
Modify the hero.name binding like this.

<h2>{{hero.name | uppercase}} Details</h2>

now the hero's name is displayed in capital letters.

The word uppercase in the interpolation binding, right after the pipe operator ( | ), activates the built-in UppercasePipe.

Pipes are a good way to format strings, currency amounts, dates and other display data.

Angular ships with several built-in pipes and you can create your own

Edit the hero

Users should be able to edit the hero name in an <input> textbox. The textbox should both display the hero's name property and update that property as the user types.

That means data flow from the component class out to the screen and from the screen back to the class. To automate that data flow, setup a two-way data binding between the <input> form element and the hero.name property.

Two-way binding

Refactor the details area in the HeroesComponent template so it looks like this:


<div>
  <label>name:
    <input [(ngModel)]="hero.name" placeholder="name">
  </label>
</div>

[(ngModel)] is Angular's two-way data binding syntax.

Here it binds the hero.name property to the HTML textbox so that data can flow in both directions: from the hero.name property to the textbox, and from the textbox back to the hero.name.

The missing FormsModule

Notice that the app stopped working when you added [(ngModel)].
Although ngModel is a valid Angular directive, it isn't available by default.
It belongs to the optional FormsModule and you must opt-in to using it.

AppModule

Angular needs to know how the pieces of your application fit together
and what other files and libraries the app requires.
This information is called metadata
Some of the metadata is in the @Component decorators that you added to your component classes.
Other critical metadata is in @NgModule decorators.
The most important @NgModule decorator annotates the top-level AppModule class.

The Angular CLI generated an AppModule class in src/app/app.module.ts when it created the project.
This is where you opt-in to the FormsModule.

Import FormsModule

Open AppModule (app.module.ts) and import the FormsModule symbol from the @angular/forms library.

import { FormsModule } from '@angular/forms'; // <-- NgModel lives here

Then add FormsModule to the @NgModule metadata's imports array, which contains a list of external modules that the app needs.

imports: [
  BrowserModule,
  FormsModule
],

app.module.ts ( @NgModule imports)

Declare HeroesComponent

Every component must be declared in exactly one NgModule
You didn't declare the HeroesComponent.
So why did the application work?
It worked because the Angular CLI declared HeroesComponent in the AppModule when it generated that component
Open src/app/app.module.ts and find HeroesComponent imported near the top.

import { HeroesComponent } from './heroes/heroes.component';

The HeroesComponent is declared in the @NgModule.declarations array.


declarations: [
  AppComponent,
  HeroesComponent
],

Note that AppModule  declares both application components, AppComponent and HeroesComponent.

Summary

You used the CLI to create a second HeroesComponent.
You displayed the HeroesComponent by adding it to the AppComponent shell. 
You applied the UppercasePipe to format the name.
You used two-way data binding with the ngModel directive.
You learned about the AppModule.
You imported the FormsModule in the AppModule so that Angular would recognize and apply the ngModel directive. 
You learned the importance of declaring components in the AppModule
and appreciated that the CLI declared it for you.



## Services

Why services

Components shouldn't fetch or save data directly and they certainly shouldn't knowingly present fake data.
They should focus on presenting data and delegate data access to a service.

Create the HeroService 
Using the Angular CLI, create a service called hero. 


ng generate service hero

The command generates skeleton HeroService class in src/app/hero.service.ts

The HeroService class should look like the following example.
src/app/hero.service.ts (new service)      
      

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class HeroService {

  constructor() { }

}

@Injectable() services

Notice that the new service imports the Angular Injectable symbol and annotates the class with the @Injectable() decorator. This marks the class as one that participates in the dependency injection system. The HeroService class is going to provide an injectable service

The @Injectable() decorator accepts a metadata object for the service

Get hero data

The HeroService could get hero data from anywhere—a web service, local storage, or a mock data source.

Removing data access from components means you can change your mind about the implementation anytime, without touching any components.

They don't know how the service works.

The implementation in this tutorial will continue to deliver mock heroes.


import { Hero } from './hero';
import { HEROES } from './mock-heroes';

// Add a getHeroes method to return the mock heroes.

getHeroes(): Hero[] {
  return HEROES;
}

Provide the HeroService

You must make the HeroService available to the dependency injection system before Angular can inject it into the HeroesComponent, as you will do below. You do this by registering a provider. A provider is something that can create or deliver a service; in this case, it instantiates the HeroService class to provide the service.

Now, you need to make sure that the HeroService is registered as the provider of this service. You are registering it with an injector, which is the object that is responsible for choosing and injecting the provider where it is required.

By default, the Angular CLI command ng generate service registers a provider with the root injector for your service by including provider metadata in the @Injectable decorator. 

the providedIn metadata value is 'root':


@Injectable({
 providedIn: 'root',
})
 
When you provide the service at the root level, Angular creates a single, shared instance of HeroService and injects into any class that asks for it.

Registering the provider in the @Injectable metadata also allows Angular to optimize an app by removing the service if it turns out not to be used after all.

To learn more about providers, see the Providers section.
To learn more about injectors, see the Dependency Injection guide.

The HeroService is now ready to plug into the HeroesComponent.

Update HeroesComponent

Open the HeroesComponent class file.
 src/app/heroes/heroes.component.ts (import HeroService) 


import { HeroService } from '../hero.service';

Replace the definition of the heroes property with a simple declaration.


heroes: Hero[];

Inject the HeroService

Add a private heroService parameter of type HeroService to the constructor.


constructor(private heroService: HeroService) { }

The parameter simultaneously defines a private heroService property and identifies it as a HeroService injection site.
When Angular creates a HeroesComponent, the Dependency Injection system sets the heroService parameter to the singleton instance of HeroService.

Add getHeroes()

Create a function to retrieve the heroes from the service.

getHeroes(): void {
  this.heroes = this.heroService.getHeroes();
}

Call it in ngOnInit

While you could call getHeroes() in the constructor, that's not the best practice.
Reserve the constructor for simple initialization such as wiring constructor parameters to properties.
The constructor shouldn't do anything.

It certainly shouldn't call a function that makes HTTP requests to a remote server as a real data service would.
Instead, call getHeroes() inside the ngOnInit lifecycle hook and let Angular call ngOnInit at an appropriate time after constructing a HeroesComponent instance.

ngOnInit() {
  this.getHeroes();
}


You refactored data access to the HeroService class.
You registered the HeroService as the provider of its service at the root level so that it can be injected anywhere in the app.
You used Angular Dependency Injection to inject it into a component.
You gave the HeroService get data method an asynchronous signature.
You discovered Observable and the RxJS Observable library.
You used RxJS of() to return an observable of mock heroes (Observable<Hero[]>).
The component's ngOnInit lifecycle hook calls the HeroService method, not the constructor.
You created a MessageService for loosely-coupled communication between classes.
The HeroService injected into a component is created with another injected service,
MessageService.
The browser refreshes and the page displays the list of heroes.
Scroll to the bottom to see the message from the HeroService in the message area.
Click the "clear" button and the message area disappears.
s

An Angular event binding binds the button's click event to MessageService.clear().

This template binds directly to the component's messageService.

The *ngIf only displays the messages area if there are messages to show.


An *ngFor presents the list of messages in repeated <div> elements.
<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>
Replace the CLI-generated MessagesComponent template with the following.
Bind to the MessageService
Angular only binds to public component properties.
The messageService property must be public because you're about to bind to it in the template.
constructor(public messageService: MessageService) {}
Modify the constructor with a parameter that declares a public messageService property.
Angular will inject the singleton MessageService into that property
when it creates the MessagesComponent.
import { MessageService } from '../message.service';
Open MessagesComponent and import the MessageService.
The MessagesComponent should display all messages,
including the message sent by the HeroService when it fetches heroes.
Display the message from HeroService
getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}

Modify the getHeroes method to send a message when the heroes are fetched.
Send a message from HeroService
This is a typical "service-in-service" scenario:
you inject the MessageService into the HeroService which is injected into the HeroesComponent.
constructor(private messageService: MessageService) { }
Modify the constructor with a parameter that declares a private messageService property.
Angular will inject the singleton MessageService into that property
when it creates the HeroService.
import { MessageService } from './message.service';
Re-open the HeroService and import the MessageService.
Inject it into the HeroService
The service exposes its cache of messages and two methods: one to add() a message to the cache and another to clear() the cache.
import { Injectable } from '@angular/core'; @Injectable({  providedIn: 'root',})export class MessageService {  messages: string[] = [];   add(message: string) {    this.messages.push(message);  }   clear() {    this.messages = [];  }}

Observable data

The HeroService.getHeroes() method has a synchronous signature,
which implies that the HeroService can fetch heroes synchronously.
The HeroesComponent consumes the getHeroes() result
as if heroes could be fetched synchronously.
Observable datalink
this.heroes = this.heroService.getHeroes();
This will not work in a real app.
You're getting away with it now because the service currently returns mock heroes.
But soon the app will fetch heroes from a remote server,
which is an inherently asynchronous operation.
The HeroService must wait for the server to respond,
getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.
HeroService.getHeroes() must have an asynchronous signature of some kind.
It can take a callback. It could return a Promise. It could return an Observable.
Observable HeroService
bservable is one of the key classes in the RxJS library.
Open the HeroService file and import the Observable and of symbols from RxJS.
src/app/hero.service.ts (Observable imports)
import { Observable, of } from 'rxjs';
Replace the getHeroes method with this one.
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}
of(HEROES) returns an Observable<Hero[]> that emits  a single value, the array of mock heroes.
Subscribe in HeroesComponentlink
The HeroService.getHeroes method used to return a Hero[].
Now it returns an Observable<Hero[]>.
You'll have to adjust to that difference in HeroesComponent.
Find the getHeroes method and replace it with the following code
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}
Observable.subscribe() is the critical difference.
The previous version assigns an array of heroes to the component's heroes property.
The assignment occurs synchronously, as if the server could return heroes instantly
or the browser could freeze the UI while it waited for the server's response.
That won't work when the HeroService is actually making requests of a remote server.
The new version waits for the Observable to emit the array of heroes—
which could happen now or several minutes from now.
Then subscribe passes the emitted array to the callback,
which sets the component's heroes property.
This asynchronous approach will work when
the HeroService requests heroes from the server.
Show messages
In this section you will 

add a MessagesComponent that displays app messages at the bottom of the screen.
create an injectable, app-wide MessageService for sending messages to be displayed
inject MessageService into the HeroService
display a message when HeroService fetches heroes successfully.

Create MessagesComponent

Modify the AppComponent template to display the generated MessagesComponent

<h1>{{title}}</h1>
<app-heroes></app-heroes>
<app-messages></app-messages>
/src/app/app.component.html

Create the MessageService

Open MessageService and replace its contents with the following.
/src/app/message.service.tsSummarylink

You refactored data access to the HeroService class.
You registered the HeroService as the provider of its service at the root level so that it can be injected anywhere in the app.
You used Angular Dependency Injection to inject it into a component.
You gave the HeroService get data method an asynchronous signature.
You discovered Observable and the RxJS Observable library.
You used RxJS of() to return an observable of mock heroes (Observable<Hero[]>).
The component's ngOnInit lifecycle hook calls the HeroService method, not the constructor.
You created a MessageService for loosely-coupled communication between classes.
The HeroService injected into a component is created with another injected service,
MessageService.
The browser refreshes and the page displays the list of heroes.
Scroll to the bottom to see the message from the HeroService in the message area.
Click the "clear" button and the message area disappears.
s
An Angular event binding binds the button's click event
to MessageService.clear().
This template binds directly to the component's messageService.

The *ngIf only displays the messages area if there are messages to show.

An *ngFor presents the list of messages in repeated <div> elements.

<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>

Replace the CLI-generated MessagesComponent template with the following.

Bind to the MessageService

Angular only binds to public component properties.

The messageService property must be public because you're about to bind to it in the template.

constructor(public messageService: MessageService) {}

Modify the constructor with a parameter that declares a public messageService property.
Angular will inject the singleton MessageService into that property when it creates the MessagesComponent.

import { MessageService } from '../message.service';

Open MessagesComponent and import the MessageService.

The MessagesComponent should display all messages,

including the message sent by the HeroService when it fetches heroes.

Display the message from HeroService

getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}

Modify the getHeroes method to send a message when the heroes are fetched.

Send a message from HeroService

This is a typical "service-in-service" scenario:
you inject the MessageService into the HeroService which is injected into the HeroesComponent.

constructor(private messageService: MessageService) { }

Modify the constructor with a parameter that declares a private messageService property.
Angular will inject the singleton MessageService into that property
when it creates the HeroService.
import { MessageService } from './message.service';
Re-open the HeroService and import the MessageService.
Inject it into the HeroService
The service exposes its cache of messages and two methods: one to add() a message to the cache and another to clear() the cache.
import { Injectable } from '@angular/core'; @Injectable({  providedIn: 'root',})export class MessageService {  messages: string[] = [];   add(message: string) {    this.messages.push(message);  }   clear() {    this.messages = [];  }}
Observable data
The HeroService.getHeroes() method has a synchronous signature,
which implies that the HeroService can fetch heroes synchronously.
The HeroesComponent consumes the getHeroes() result
as if heroes could be fetched synchronously.
Observable datalink
this.heroes = this.heroService.getHeroes();
This will not work in a real app.
You're getting away with it now because the service currently returns mock heroes.
But soon the app will fetch heroes from a remote server,
which is an inherently asynchronous operation.
The HeroService must wait for the server to respond,
getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.
HeroService.getHeroes() must have an asynchronous signature of some kind.
It can take a callback. It could return a Promise. It could return an Observable.
Observable HeroService
bservable is one of the key classes in the RxJS library.
Open the HeroService file and import the Observable and of symbols from RxJS.
src/app/hero.service.ts (Observable imports)
import { Observable, of } from 'rxjs';
Replace the getHeroes method with this one.
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}
of(HEROES) returns an Observable<Hero[]> that emits  a single value, the array of mock heroes.
Subscribe in HeroesComponentlink
The HeroService.getHeroes method used to return a Hero[].
Now it returns an Observable<Hero[]>.
You'll have to adjust to that difference in HeroesComponent.
Find the getHeroes method and replace it with the following code
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}
Observable.subscribe() is the critical difference.
The previous version assigns an array of heroes to the component's heroes property.
The assignment occurs synchronously, as if the server could return heroes instantly
or the browser could freeze the UI while it waited for the server's response.
That won't work when the HeroService is actually making requests of a remote server.
The new version waits for the Observable to emit the array of heroes—
which could happen now or several minutes from now.
Then subscribe passes the emitted array to the callback,
which sets the component's heroes property.
This asynchronous approach will work when
the HeroService requests heroes from the server.
Show messages
In this section you will 

add a MessagesComponent that displays app messages at the bottom of the screen.
create an injectable, app-wide MessageService for sending messages to be displayed
inject MessageService into the HeroService
display a message when HeroService fetches heroes successfully.
Create MessagesComponent
Modify the AppComponent template to display the generated MessagesComponent
<h1>{{title}}</h1>
<app-heroes></app-heroes>
<app-messages></app-messages>
/src/app/app.component.html
Create the MessageService
Open MessageService and replace its contents with the following.
/src/app/message.service.tsSummarylink

You refactored data access to the HeroService class.
You registered the HeroService as the provider of its service at the root level so that it can be injected anywhere in the app.
You used Angular Dependency Injection to inject it into a component.
You gave the HeroService get data method an asynchronous signature.
You discovered Observable and the RxJS Observable library.
You used RxJS of() to return an observable of mock heroes (Observable<Hero[]>).
The component's ngOnInit lifecycle hook calls the HeroService method, not the constructor.
You created a MessageService for loosely-coupled communication between classes.
The HeroService injected into a component is created with another injected service,
MessageService.
The browser refreshes and the page displays the list of heroes.
Scroll to the bottom to see the message from the HeroService in the message area.
Click the "clear" button and the message area disappears.
s
An Angular event binding binds the button's click event
to MessageService.clear().
This template binds directly to the component's messageService.

The *ngIf only displays the messages area if there are messages to show.


An *ngFor presents the list of messages in repeated <div> elements.
<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>
Replace the CLI-generated MessagesComponent template with the following.
Bind to the MessageService
Angular only binds to public component properties.
The messageService property must be public because you're about to bind to it in the template.
constructor(public messageService: MessageService) {}
Modify the constructor with a parameter that declares a public messageService property.
Angular will inject the singleton MessageService into that property
when it creates the MessagesComponent.
import { MessageService } from '../message.service';
Open MessagesComponent and import the MessageService.
The MessagesComponent should display all messages,
including the message sent by the HeroService when it fetches heroes.
Display the message from HeroService
getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}
Modify the getHeroes method to send a message when the heroes are fetched.
Send a message from HeroService
This is a typical "service-in-service" scenario:
you inject the MessageService into the HeroService which is injected into the HeroesComponent.
constructor(private messageService: MessageService) { }
Modify the constructor with a parameter that declares a private messageService property.
Angular will inject the singleton MessageService into that property
when it creates the HeroService.
import { MessageService } from './message.service';
Re-open the HeroService and import the MessageService.
Inject it into the HeroService
The service exposes its cache of messages and two methods: one to add() a message to the cache and another to clear() the cache.
import { Injectable } from '@angular/core'; @Injectable({  providedIn: 'root',})export class MessageService {  messages: string[] = [];   add(message: string) {    this.messages.push(message);  }   clear() {    this.messages = [];  }}
Observable data
The HeroService.getHeroes() method has a synchronous signature,
which implies that the HeroService can fetch heroes synchronously.
The HeroesComponent consumes the getHeroes() result
as if heroes could be fetched synchronously.
Observable datalink
this.heroes = this.heroService.getHeroes();
This will not work in a real app.
You're getting away with it now because the service currently returns mock heroes.
But soon the app will fetch heroes from a remote server,
which is an inherently asynchronous operation.
The HeroService must wait for the server to respond,
getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.
HeroService.getHeroes() must have an asynchronous signature of some kind.
It can take a callback. It could return a Promise. It could return an Observable.
Observable HeroService
bservable is one of the key classes in the RxJS library.
Open the HeroService file and import the Observable and of symbols from RxJS.
src/app/hero.service.ts (Observable imports)
import { Observable, of } from 'rxjs';
Replace the getHeroes method with this one.
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}
of(HEROES) returns an Observable<Hero[]> that emits  a single value, the array of mock heroes.
Subscribe in HeroesComponentlink
The HeroService.getHeroes method used to return a Hero[].
Now it returns an Observable<Hero[]>.
You'll have to adjust to that difference in HeroesComponent.
Find the getHeroes method and replace it with the following code
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}
Observable.subscribe() is the critical difference.
The previous version assigns an array of heroes to the component's heroes property.
The assignment occurs synchronously, as if the server could return heroes instantly
or the browser could freeze the UI while it waited for the server's response.
That won't work when the HeroService is actually making requests of a remote server.
The new version waits for the Observable to emit the array of heroes—
which could happen now or several minutes from now.
Then subscribe passes the emitted array to the callback,
which sets the component's heroes property.
This asynchronous approach will work when
the HeroService requests heroes from the server.
Show messages
In this section you will 

add a MessagesComponent that displays app messages at the bottom of the screen.
create an injectable, app-wide MessageService for sending messages to be displayed
inject MessageService into the HeroService
display a message when HeroService fetches heroes successfully.
Create MessagesComponent
Modify the AppComponent template to display the generated MessagesComponent
<h1>{{title}}</h1>
<app-heroes></app-heroes>
<app-messages></app-messages>
/src/app/app.component.html
Create the MessageService
Open MessageService and replace its contents with the following.
/src/app/message.service.tsSummarylink

You refactored data access to the HeroService class.
You registered the HeroService as the provider of its service at the root level so that it can be injected anywhere in the app.
You used Angular Dependency Injection to inject it into a component.
You gave the HeroService get data method an asynchronous signature.
You discovered Observable and the RxJS Observable library.
You used RxJS of() to return an observable of mock heroes (Observable<Hero[]>).
The component's ngOnInit lifecycle hook calls the HeroService method, not the constructor.
You created a MessageService for loosely-coupled communication between classes.
The HeroService injected into a component is created with another injected service,
MessageService.
The browser refreshes and the page displays the list of heroes.
Scroll to the bottom to see the message from the HeroService in the message area.
Click the "clear" button and the message area disappears.
s
An Angular event binding binds the button's click event
to MessageService.clear().
This template binds directly to the component's messageService.

The *ngIf only displays the messages area if there are messages to show.


An *ngFor presents the list of messages in repeated <div> elements.
<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>
Replace the CLI-generated MessagesComponent template with the following.
Bind to the MessageService
Angular only binds to public component properties.
The messageService property must be public because you're about to bind to it in the template.
constructor(public messageService: MessageService) {}
Modify the constructor with a parameter that declares a public messageService property.
Angular will inject the singleton MessageService into that property
when it creates the MessagesComponent.
import { MessageService } from '../message.service';
Open MessagesComponent and import the MessageService.
The MessagesComponent should display all messages,
including the message sent by the HeroService when it fetches heroes.
Display the message from HeroService
getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}
Modify the getHeroes method to send a message when the heroes are fetched.
Send a message from HeroService
This is a typical "service-in-service" scenario:
you inject the MessageService into the HeroService which is injected into the HeroesComponent.
constructor(private messageService: MessageService) { }
Modify the constructor with a parameter that declares a private messageService property.
Angular will inject the singleton MessageService into that property
when it creates the HeroService.
import { MessageService } from './message.service';
Re-open the HeroService and import the MessageService.
Inject it into the HeroService
The service exposes its cache of messages and two methods: one to add() a message to the cache and another to clear() the cache.
import { Injectable } from '@angular/core'; @Injectable({  providedIn: 'root',})export class MessageService {  messages: string[] = [];   add(message: string) {    this.messages.push(message);  }   clear() {    this.messages = [];  }}
Observable data
The HeroService.getHeroes() method has a synchronous signature,
which implies that the HeroService can fetch heroes synchronously.
The HeroesComponent consumes the getHeroes() result
as if heroes could be fetched synchronously.
Observable datalink
this.heroes = this.heroService.getHeroes();
This will not work in a real app.
You're getting away with it now because the service currently returns mock heroes.
But soon the app will fetch heroes from a remote server,
which is an inherently asynchronous operation.
The HeroService must wait for the server to respond,
getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.
HeroService.getHeroes() must have an asynchronous signature of some kind.
It can take a callback. It could return a Promise. It could return an Observable.
Observable HeroService
bservable is one of the key classes in the RxJS library.
Open the HeroService file and import the Observable and of symbols from RxJS.
src/app/hero.service.ts (Observable imports)
import { Observable, of } from 'rxjs';
Replace the getHeroes method with this one.
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}
of(HEROES) returns an Observable<Hero[]> that emits  a single value, the array of mock heroes.
Subscribe in HeroesComponentlink
The HeroService.getHeroes method used to return a Hero[].
Now it returns an Observable<Hero[]>.
You'll have to adjust to that difference in HeroesComponent.
Find the getHeroes method and replace it with the following code
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}
Observable.subscribe() is the critical difference.
The previous version assigns an array of heroes to the component's heroes property.
The assignment occurs synchronously, as if the server could return heroes instantly
or the browser could freeze the UI while it waited for the server's response.
That won't work when the HeroService is actually making requests of a remote server.
The new version waits for the Observable to emit the array of heroes—
which could happen now or several minutes from now.
Then subscribe passes the emitted array to the callback,
which sets the component's heroes property.
This asynchronous approach will work when
the HeroService requests heroes from the server.
Show messages
In this section you will 

add a MessagesComponent that displays app messages at the bottom of the screen.
create an injectable, app-wide MessageService for sending messages to be displayed
inject MessageService into the HeroService
display a message when HeroService fetches heroes successfully.
Create MessagesComponent
Modify the AppComponent template to display the generated MessagesComponent
<h1>{{title}}</h1>
<app-heroes></app-heroes>
<app-messages></app-messages>
/src/app/app.component.html
Create the MessageService
Open MessageService and replace its contents with the following.
/src/app/message.service.tsSummarylink

You refactored data access to the HeroService class.
You registered the HeroService as the provider of its service at the root level so that it can be injected anywhere in the app.
You used Angular Dependency Injection to inject it into a component.
You gave the HeroService get data method an asynchronous signature.
You discovered Observable and the RxJS Observable library.
You used RxJS of() to return an observable of mock heroes (Observable<Hero[]>).
The component's ngOnInit lifecycle hook calls the HeroService method, not the constructor.
You created a MessageService for loosely-coupled communication between classes.
The HeroService injected into a component is created with another injected service,
MessageService.
The browser refreshes and the page displays the list of heroes.
Scroll to the bottom to see the message from the HeroService in the message area.
Click the "clear" button and the message area disappears.
s
An Angular event binding binds the button's click event
to MessageService.clear().
This template binds directly to the component's messageService.

The *ngIf only displays the messages area if there are messages to show.


An *ngFor presents the list of messages in repeated <div> elements.
<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>
Replace the CLI-generated MessagesComponent template with the following.
Bind to the MessageService
Angular only binds to public component properties.
The messageService property must be public because you're about to bind to it in the template.
constructor(public messageService: MessageService) {}
Modify the constructor with a parameter that declares a public messageService property.
Angular will inject the singleton MessageService into that property
when it creates the MessagesComponent.
import { MessageService } from '../message.service';
Open MessagesComponent and import the MessageService.
The MessagesComponent should display all messages,
including the message sent by the HeroService when it fetches heroes.
Display the message from HeroService
getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}
Modify the getHeroes method to send a message when the heroes are fetched.
Send a message from HeroService
This is a typical "service-in-service" scenario:
you inject the MessageService into the HeroService which is injected into the HeroesComponent.
constructor(private messageService: MessageService) { }
Modify the constructor with a parameter that declares a private messageService property.
Angular will inject the singleton MessageService into that property
when it creates the HeroService.
import { MessageService } from './message.service';
Re-open the HeroService and import the MessageService.
Inject it into the HeroService
The service exposes its cache of messages and two methods: one to add() a message to the cache and another to clear() the cache.
import { Injectable } from '@angular/core'; @Injectable({  providedIn: 'root',})export class MessageService {  messages: string[] = [];   add(message: string) {    this.messages.push(message);  }   clear() {    this.messages = [];  }}
Observable data
The HeroService.getHeroes() method has a synchronous signature,
which implies that the HeroService can fetch heroes synchronously.
The HeroesComponent consumes the getHeroes() result
as if heroes could be fetched synchronously.
Observable datalink
this.heroes = this.heroService.getHeroes();
This will not work in a real app.
You're getting away with it now because the service currently returns mock heroes.
But soon the app will fetch heroes from a remote server,
which is an inherently asynchronous operation.
The HeroService must wait for the server to respond,
getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.
HeroService.getHeroes() must have an asynchronous signature of some kind.
It can take a callback. It could return a Promise. It could return an Observable.
Observable HeroService
bservable is one of the key classes in the RxJS library.
Open the HeroService file and import the Observable and of symbols from RxJS.
src/app/hero.service.ts (Observable imports)
import { Observable, of } from 'rxjs';
Replace the getHeroes method with this one.
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}
of(HEROES) returns an Observable<Hero[]> that emits  a single value, the array of mock heroes.
Subscribe in HeroesComponentlink
The HeroService.getHeroes method used to return a Hero[].
Now it returns an Observable<Hero[]>.
You'll have to adjust to that difference in HeroesComponent.
Find the getHeroes method and replace it with the following code
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}
Observable.subscribe() is the critical difference.
The previous version assigns an array of heroes to the component's heroes property.
The assignment occurs synchronously, as if the server could return heroes instantly
or the browser could freeze the UI while it waited for the server's response.
That won't work when the HeroService is actually making requests of a remote server.
The new version waits for the Observable to emit the array of heroes—
which could happen now or several minutes from now.
Then subscribe passes the emitted array to the callback,
which sets the component's heroes property.
This asynchronous approach will work when
the HeroService requests heroes from the server.
Show messages
In this section you will 

add a MessagesComponent that displays app messages at the bottom of the screen.
create an injectable, app-wide MessageService for sending messages to be displayed
inject MessageService into the HeroService
display a message when HeroService fetches heroes successfully.
Create MessagesComponent
Modify the AppComponent template to display the generated MessagesComponent
<h1>{{title}}</h1>
<app-heroes></app-heroes>
<app-messages></app-messages>
/src/app/app.component.html
Create the MessageService
Open MessageService and replace its contents with the following.
/src/app/message.service.tsSummarylink

You refactored data access to the HeroService class.
You registered the HeroService as the provider of its service at the root level so that it can be injected anywhere in the app.
You used Angular Dependency Injection to inject it into a component.
You gave the HeroService get data method an asynchronous signature.
You discovered Observable and the RxJS Observable library.
You used RxJS of() to return an observable of mock heroes (Observable<Hero[]>).
The component's ngOnInit lifecycle hook calls the HeroService method, not the constructor.
You created a MessageService for loosely-coupled communication between classes.
The HeroService injected into a component is created with another injected service,
MessageService.
The browser refreshes and the page displays the list of heroes.
Scroll to the bottom to see the message from the HeroService in the message area.
Click the "clear" button and the message area disappears.
s
An Angular event binding binds the button's click event
to MessageService.clear().
This template binds directly to the component's messageService.

The *ngIf only displays the messages area if there are messages to show.


An *ngFor presents the list of messages in repeated <div> elements.
<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>
Replace the CLI-generated MessagesComponent template with the following.
Bind to the MessageService
Angular only binds to public component properties.
The messageService property must be public because you're about to bind to it in the template.
constructor(public messageService: MessageService) {}
Modify the constructor with a parameter that declares a public messageService property.
Angular will inject the singleton MessageService into that property
when it creates the MessagesComponent.
import { MessageService } from '../message.service';
Open MessagesComponent and import the MessageService.
The MessagesComponent should display all messages,
including the message sent by the HeroService when it fetches heroes.
Display the message from HeroService
getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}
Modify the getHeroes method to send a message when the heroes are fetched.
Send a message from HeroService
This is a typical "service-in-service" scenario:
you inject the MessageService into the HeroService which is injected into the HeroesComponent.
constructor(private messageService: MessageService) { }
Modify the constructor with a parameter that declares a private messageService property.
Angular will inject the singleton MessageService into that property
when it creates the HeroService.
import { MessageService } from './message.service';
Re-open the HeroService and import the MessageService.
Inject it into the HeroService
The service exposes its cache of messages and two methods: one to add() a message to the cache and another to clear() the cache.
import { Injectable } from '@angular/core'; @Injectable({  providedIn: 'root',})export class MessageService {  messages: string[] = [];   add(message: string) {    this.messages.push(message);  }   clear() {    this.messages = [];  }}
Observable data
The HeroService.getHeroes() method has a synchronous signature,
which implies that the HeroService can fetch heroes synchronously.
The HeroesComponent consumes the getHeroes() result
as if heroes could be fetched synchronously.
Observable datalink
this.heroes = this.heroService.getHeroes();
This will not work in a real app.
You're getting away with it now because the service currently returns mock heroes.
But soon the app will fetch heroes from a remote server,
which is an inherently asynchronous operation.
The HeroService must wait for the server to respond,
getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.
HeroService.getHeroes() must have an asynchronous signature of some kind.
It can take a callback. It could return a Promise. It could return an Observable.
Observable HeroService
bservable is one of the key classes in the RxJS library.
Open the HeroService file and import the Observable and of symbols from RxJS.
src/app/hero.service.ts (Observable imports)
import { Observable, of } from 'rxjs';
Replace the getHeroes method with this one.
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}
of(HEROES) returns an Observable<Hero[]> that emits  a single value, the array of mock heroes.
Subscribe in HeroesComponentlink
The HeroService.getHeroes method used to return a Hero[].
Now it returns an Observable<Hero[]>.
You'll have to adjust to that difference in HeroesComponent.
Find the getHeroes method and replace it with the following code
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}
Observable.subscribe() is the critical difference.
The previous version assigns an array of heroes to the component's heroes property.
The assignment occurs synchronously, as if the server could return heroes instantly
or the browser could freeze the UI while it waited for the server's response.
That won't work when the HeroService is actually making requests of a remote server.
The new version waits for the Observable to emit the array of heroes—
which could happen now or several minutes from now.
Then subscribe passes the emitted array to the callback,
which sets the component's heroes property.
This asynchronous approach will work when
the HeroService requests heroes from the server.
Show messages
In this section you will 

add a MessagesComponent that displays app messages at the bottom of the screen.
create an injectable, app-wide MessageService for sending messages to be displayed
inject MessageService into the HeroService
display a message when HeroService fetches heroes successfully.
Create MessagesComponent
Modify the AppComponent template to display the generated MessagesComponent
<h1>{{title}}</h1>
<app-heroes></app-heroes>
<app-messages></app-messages>
/src/app/app.component.html
Create the MessageService
Open MessageService and replace its contents with the following.
/src/app/message.service.tsSummarylink

You refactored data access to the HeroService class.
You registered the HeroService as the provider of its service at the root level so that it can be injected anywhere in the app.
You used Angular Dependency Injection to inject it into a component.
You gave the HeroService get data method an asynchronous signature.
You discovered Observable and the RxJS Observable library.
You used RxJS of() to return an observable of mock heroes (Observable<Hero[]>).
The component's ngOnInit lifecycle hook calls the HeroService method, not the constructor.
You created a MessageService for loosely-coupled communication between classes.
The HeroService injected into a component is created with another injected service,
MessageService.
The browser refreshes and the page displays the list of heroes.
Scroll to the bottom to see the message from the HeroService in the message area.
Click the "clear" button and the message area disappears.
s
An Angular event binding binds the button's click event
to MessageService.clear().
This template binds directly to the component's messageService.

The *ngIf only displays the messages area if there are messages to show.


An *ngFor presents the list of messages in repeated <div> elements.
<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>
Replace the CLI-generated MessagesComponent template with the following.
Bind to the MessageService
Angular only binds to public component properties.
The messageService property must be public because you're about to bind to it in the template.
constructor(public messageService: MessageService) {}
Modify the constructor with a parameter that declares a public messageService property.
Angular will inject the singleton MessageService into that property
when it creates the MessagesComponent.
import { MessageService } from '../message.service';
Open MessagesComponent and import the MessageService.
The MessagesComponent should display all messages,
including the message sent by the HeroService when it fetches heroes.
Display the message from HeroService
getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}
Modify the getHeroes method to send a message when the heroes are fetched.
Send a message from HeroService
This is a typical "service-in-service" scenario:
you inject the MessageService into the HeroService which is injected into the HeroesComponent.
constructor(private messageService: MessageService) { }
Modify the constructor with a parameter that declares a private messageService property.
Angular will inject the singleton MessageService into that property
when it creates the HeroService.
import { MessageService } from './message.service';
Re-open the HeroService and import the MessageService.
Inject it into the HeroService
The service exposes its cache of messages and two methods: one to add() a message to the cache and another to clear() the cache.
import { Injectable } from '@angular/core'; @Injectable({  providedIn: 'root',})export class MessageService {  messages: string[] = [];   add(message: string) {    this.messages.push(message);  }   clear() {    this.messages = [];  }}
Observable data
The HeroService.getHeroes() method has a synchronous signature,
which implies that the HeroService can fetch heroes synchronously.
The HeroesComponent consumes the getHeroes() result
as if heroes could be fetched synchronously.
Observable datalink
this.heroes = this.heroService.getHeroes();
This will not work in a real app.
You're getting away with it now because the service currently returns mock heroes.
But soon the app will fetch heroes from a remote server,
which is an inherently asynchronous operation.
The HeroService must wait for the server to respond,
getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.
HeroService.getHeroes() must have an asynchronous signature of some kind.
It can take a callback. It could return a Promise. It could return an Observable.
Observable HeroService
bservable is one of the key classes in the RxJS library.
Open the HeroService file and import the Observable and of symbols from RxJS.
src/app/hero.service.ts (Observable imports)
import { Observable, of } from 'rxjs';
Replace the getHeroes method with this one.
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}
of(HEROES) returns an Observable<Hero[]> that emits  a single value, the array of mock heroes.
Subscribe in HeroesComponentlink
The HeroService.getHeroes method used to return a Hero[].
Now it returns an Observable<Hero[]>.
You'll have to adjust to that difference in HeroesComponent.
Find the getHeroes method and replace it with the following code
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}
Observable.subscribe() is the critical difference.
The previous version assigns an array of heroes to the component's heroes property.
The assignment occurs synchronously, as if the server could return heroes instantly
or the browser could freeze the UI while it waited for the server's response.
That won't work when the HeroService is actually making requests of a remote server.
The new version waits for the Observable to emit the array of heroes—
which could happen now or several minutes from now.
Then subscribe passes the emitted array to the callback,
which sets the component's heroes property.
This asynchronous approach will work when
the HeroService requests heroes from the server.
Show messages
In this section you will 

add a MessagesComponent that displays app messages at the bottom of the screen.
create an injectable, app-wide MessageService for sending messages to be displayed
inject MessageService into the HeroService
display a message when HeroService fetches heroes successfully.
Create MessagesComponent
Modify the AppComponent template to display the generated MessagesComponent
<h1>{{title}}</h1>
<app-heroes></app-heroes>
<app-messages></app-messages>
/src/app/app.component.html
Create the MessageService
Open MessageService and replace its contents with the following.
/src/app/message.service.ts