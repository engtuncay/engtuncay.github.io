
Source : https://www.javascripttutorial.net/es6/javascript-promises/

(some parts may be modified or removed)

[Back](../readme.md)

---

- [JavaScript Promises](#javascript-promises)
  - [Creating a promise](#creating-a-promise)
  - [Consuming a Promise: then, catch, finally](#consuming-a-promise-then-catch-finally)
  - [2) The catch() method](#2-the-catch-method)
  - [3) The finally() method](#3-the-finally-method)
- [Promise Chaining](#promise-chaining)


# JavaScript Promises

In practice, the getUsers() function may access a database or call an API to get the user list. Therefore, the getUsers() function will have a **delay**

The challenge is how to access the users returned from the getUsers() function after one second. One classical approach is to use the **callback**

âž– Using callbacks to deal with an asynchronous operation

The following example adds a callback argument to the getUsers() and findUser() functions:

```js
function getUsers(callback) {
  setTimeout(() => {
    callback([
      { username: 'john', email: 'john@test.com' },
      { username: 'jane', email: 'jane@test.com' },
    ]);
  }, 1000);
}

function findUser(username, callback) {
  getUsers((users) => {
    const user = users.find((user) => user.username === username);
    callback(user);
  });
}

findUser('john', console.log);

// Output:
// 
// { username: 'john', email: 'john@test.com' }

```

In this example, the getUsers() function accepts a callback function as an argument and invokes it with the users array inside the setTimeout() function. Also, the findUser() function accepts a callback function that processes the matched user.

The callback approach works very well. However, it makes the code more difficult to follow. Also, it adds complexity to the functions with callback arguments.

If the number of functions grows, you may end up with the `callback hell` problem. To resolve this, JavaScript comes up with the concept of promises.

âž– Understanding JavaScript Promises

By definition, a promise is `an object that encapsulates the result of an asynchronous operation`.

A promise object has a state that can be one of the following:

- Pending
- Fulfilled with a value
- Rejected for a reason

In the beginning, the state of a promise is pending, indicating that the asynchronous operation is in progress. Depending on the result of the asynchronous operation, the state changes to either fulfilled or rejected.

The fulfilled state indicates that the asynchronous operation was completed successfully:

âž– JavaScript Promise Fulfilled

The rejected state indicates that the asynchronous operation failed.

## Creating a promise

To create a promise object, you use the Promise() constructor:

```js
const promise = new Promise((resolve, reject) => {
  // contain an operation
  // ...

  // return the state
  if (success) {
    resolve(value);
  } else {
    reject(error);
  }
});

```

The promise constructor accepts `a callback function (with two arguments)` that typically performs an asynchronous operation. This function is often referred to as `an executor`.

In turn, the executor accepts two callback functions (two arguments) with the name `resolve and reject`.

Note that the callback functions passed into the executor are resolve and reject by convention only.

If the asynchronous operation completes successfully, the executor will call the resolve() function to `change the state of the promise from pending to fulfilled with a value`.

In case of an error, the executor will call the reject() function to change the state of the promise from pending to rejected with the error reason.

Once a promise reaches either a fulfilled or rejected state, it stays in that state and canâ€™t go to another state.

In other words, a promise cannot go from the fulfilled state to the rejected state and vice versa. Also, it cannot go back from the fulfilled or rejected state to the pending state.

Once a new Promise object is created, its state is pending. If a promise reaches fulfilled or rejected state, it is resolved.

ðŸ“ Note that you will rarely create promise objects in practice. Instead, you will consume promises provided by libraries.

## Consuming a Promise: then, catch, finally

1) then() method

To get the value of a promise when itâ€™s fulfilled, you call the then() method of the promise object. The following shows the syntax of the then() method:

```js
promise.then(onFulfilled,onRejected);

```

The then() method accepts two callback functions: onFulfilled and onRejected.

The then() method calls the onFulfilled() with a value, if the promise is fulfilled or the onRejected() with an error if the promise is rejected.

Note that both onFulfilled and onRejected arguments are optional.

The following example shows how to use then() method of the Promise object returned by the getUsers() function:

```js
function getUsers() {
  
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // resolve is like emit,trigger function, but for errors, reject function is used
      resolve([
        { username: 'john', email: 'john@test.com' },
        { username: 'jane', email: 'jane@test.com' },
      ]);
    }, 1000);
  });
}

const promise = getUsers();

promise.then((users) => {
  console.log(users);
});

```

In this example:

- First, call the getUsers() function to get a promise object (promise body (executor) is executed).
- Second, define a then operation (resolve) when the promise is fulfilled and output the user list to the console.

Because the getUsers() function returns a promise object, you can chain the function call with the then() method like this:

```js
// getUsers() function
//...

getUsers().then((users) => {
  console.log(users);
});

```

âž– reject usage

In this example, the getUsers() function always succeeds. To simulate the error, we can use a success flag like the following:

```js
let success = true;

function getUsers() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (success) {
        resolve([
          { username: 'john', email: 'john@test.com' },
          { username: 'jane', email: 'jane@test.com' },
        ]);
      } else {
        reject('Failed to the user list');
      }
    }, 1000);
  });
}

function onFulfilled(users) {
  console.log(users);
}
function onRejected(error) {
  console.log(error);
}

const promise = getUsers();
promise.then(onFulfilled, onRejected);

```

How it works.

- First, define the success variable and initialize its value to true.

- If the success is true, the promise in the getUsers() function is fulfilled with a user list. Otherwise, it is rejected with an error message.

- Second, define the onFulfilled and onRejected functions.

- Third, get the promise from the getUsers() function and call the then() method with the onFulfilled and onRejected functions.

The following shows how to use the arrow functions as the arguments of the then() method:

```js
// getUsers() function
// ...

const promise = getUsers();
promise.then(
  (users) => console.log,
  (error) => console.log
);

```

## 2) The catch() method

If you want to get the error only when the state of the promise is rejected, you can use the catch() method of the Promise object:

```js
promise.catch(onRejected);

```

Internally, the catch() method invokes the then(undefined, onRejected) method.

The following example changes the success flag to false to simulate the error scenario:

```js
let success = false;

function getUsers() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (success) {
        resolve([
          { username: 'john', email: 'john@test.com' },
          { username: 'jane', email: 'jane@test.com' },
        ]);
      } else {
        reject('Failed to the user list');
      }
    }, 1000);
  });
}

const promise = getUsers();

promise.catch((error) => {
  console.log(error);
});

```

##  3) The finally() method

Sometimes, you want to execute the same piece of code whether the promise is fulfilled or rejected. For example:

```js
const render = () => {
  //...
};

getUsers()
  .then((users) => {
    console.log(users);
    render();
  })
  .catch((error) => {
    console.log(error);
    render();
  });

```

As you can see, the render() function call is duplicated in both then() and catch() methods.

To remove this duplicate and execute the render() whether the promise is fulfilled or rejected, you use the finally() method, like this:

```js
const render = () => {
  //...
};

getUsers()
  .then((users) => {
    console.log(users);
  })
  .catch((error) => {
    console.log(error);
  })
  .finally(() => {
    render();
  });

```

A practical JavaScript Promise example
The following example shows how to load a JSON file from the server and display its contents on a webpage.

Suppose you have the following JSON file:

```js
https://www.javascripttutorial.net/sample/promise/api.json

```

with the following contents:

```js
{
    "message": "JavaScript Promise Demo"
}

```

The following shows the HTML page that contains a button. When you click the button, the page loads data from the JSON file and shows the message:

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>JavaScript Promise Demo</title>
    <link href="css/style.css" rel="stylesheet">
</head>
<body>
    <div id="container">
        <div id="message"></div>
        <button id="btnGet">Get Message</button>
    </div>
    <script src="js/promise-demo.js">
    </script>
</body>
</html>

```

The following shows the promise-demo.js file:

```js
function load(url) {
  return new Promise(function (resolve, reject) {
    const request = new XMLHttpRequest();
    request.onreadystatechange = function () {
      if (this.readyState === 4 && this.status == 200) {
        resolve(this.response);
      } else {
        reject(this.status);
      }
    };
    request.open('GET', url, true);
    request.send();
  });
}

const url = 'https://www.javascripttutorial.net/sample/promise/api.json';
const btn = document.querySelector('#btnGet');
const msg = document.querySelector('#message');

btn.addEventListener('click', () => {
  load(URL)
    .then((response) => {
      const result = JSON.parse(response);
      msg.innerHTML = result.message;
    })
    .catch((error) => {
      msg.innerHTML = `Error getting the message, HTTP status: ${error}`;
    });
});

```

How it works.

First, define the load() function that uses the XMLHttpRequest object to load the JSON file from the server:

```js
function load(url) {
  return new Promise(function (resolve, reject) {
    const request = new XMLHttpRequest();
    request.onreadystatechange = function () {
      if (this.readyState === 4 && this.status == 200) {
        resolve(this.response);
      } else {
        reject(this.status);
      }
    };
    request.open('GET', url, true);
    request.send();
  });
}

```

In the executor, we call resolve() function with the Response if the HTTP status code is 200. Otherwise, we invoke the reject() function with the HTTP status code.

Second, register the button click event listener, and call the then() method of the promise object. If the load is successful, then we show the message returned from the server. Otherwise, we show the error message with the HTTP status code.

```js
const url = 'https://www.javascripttutorial.net/sample/promise/api.json';
const btn = document.querySelector('#btnGet');
const msg = document.querySelector('#message');

btn.addEventListener('click', () => {
  load(URL)
    .then((response) => {
      const result = JSON.parse(response);
      msg.innerHTML = result.message;
    })
    .catch((error) => {
      msg.innerHTML = `Error getting the message, HTTP status: ${error}`;
    });
});

```

âž– Summary

- A promise is an object that encapsulates the result of an asynchronous operation.
- A promise starts in the pending state and ends in either a fulfilled state or a rejected state.
- Use then() method to schedule a callback to be executed when the promise is fulfilled, and catch() method to schedule a callback to be invoked when the promise is rejected.
- Place the code that you want to execute in the finally() method whether the promise is fulfilled or rejected.


# Promise Chaining

Sometimes, you want to execute two or more related asynchronous operations, where the next operation starts with the result from the previous one. For example:

First, create a new promise that resolves to the number 10 after 3 seconds:

```js
let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 3 * 100);
});

```
Note that the setTimeout() function simulates an asynchronous operation.

Then, invoke the then() method of the promise:

```js
p.then((result) => {
    console.log(result);
    return result * 2;
});

```

The callback passed to the then() method executes once the promise is resolved. In the callback, we show the result of the promise and return a new value multiplied by two (result*2).

Because the then() method returns a new Promise with a value resolved to a value, you can call the then() method on the return Promise like this:

```js
let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 3 * 100);
});

p.then((result) => {
    console.log(result);
    return result * 2;
}).then((result) => {
    console.log(result);
    return result * 3;
});

// Output:
// 
// 10
// 20
```

In this example, the return value in the first then() method is passed to the second then() method. You can keep calling the then() method successively as follows:

```js
let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 3 * 100);
});

p.then((result) => {
    console.log(result); // 10
    return result * 2;
}).then((result) => {
    console.log(result); // 20
    return result * 3;
}).then((result) => {
    console.log(result); // 60
    return result * 4;
});

// Output:
// 
// 10
// 20
// 60

```

The way we call the then() method like this is often referred to as `a promise chain`.

âž– Multiple handlers for a promise

When you call the then() method multiple times on a promise, it is not the promise chaining. For example:

```js
let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 3 * 100);
});

p.then((result) => {
    console.log(result); // 10
    return result * 2;
})

p.then((result) => {
    console.log(result); // 10
    return result * 3;
})

p.then((result) => {
    console.log(result); // 10
    return result * 4;
});

// Output:
// 
// 10
// 10
// 10

```

In this example, we have multiple handlers for one promise. These handlers have no relationships. Also, they execute independently and donâ€™t pass the result from one to another like the promise chain above.

In practice, you will rarely use multiple handlers for one promise.

âž– Returning a Promise â—

When you return a value in the then() method, the then() method returns `a new Promise that immediately resolves to the return value`.

Also, you can return a new promise in the then() method, like this:

```js
let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(10);
    }, 3 * 100);
});

p.then((result) => {
    console.log(result);
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(result * 2);
        }, 3 * 1000);
    });
}).then((result) => {
    console.log(result);
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(result * 3);
        }, 3 * 1000);
    });
}).then(result => console.log(result));

// Output:
// 
// 10
// 20
// 60

```

This example shows 10, 20, and 60 after every 3 seconds. This code pattern allows you to execute some tasks in sequence.

The following modified the above example:

```js
function generateNumber(num) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(num);
    }, 3 * 1000);
  });
}

generateNumber(10)
  .then((result) => {
    console.log(result);
    return generateNumber(result * 2);
  })
  .then((result) => {
    console.log(result);
    return generateNumber(result * 3);
  })
  .then((result) => console.log(result));

```

âž– Promise chaining syntax

Sometimes, you have multiple asynchronous tasks you want to execute in sequence. In addition, you need to pass the result of the previous step to the next one. In this case, you can use the following syntax:

```js
step1()
    .then(result => step2(result))
    .then(result => step3(result))
    ...

```

If you need to pass the result of the previous task to the next one without passing the result, you use this syntax:

```js
step1()
    .then(step2)
    .then(step3)
    ...

```

Suppose that you want to perform the following asynchronous operations in sequence:

- First, get the user from the database.
- Second, get the services of the selected user.
- Third, calculate the service cost from the userâ€™s services.

The following functions illustrate the three asynchronous operations:

```js
function getUser(userId) {
    return new Promise((resolve, reject) => {
        console.log('Get the user from the database.');
        setTimeout(() => {
            resolve({
                userId: userId,
                username: 'admin'
            });
        }, 1000);
    })
}

function getServices(user) {
    return new Promise((resolve, reject) => {
        console.log(`Get the services of ${user.username} from the API.`);
        setTimeout(() => {
            resolve(['Email', 'VPN', 'CDN']);
        }, 3 * 1000);
    });
}

function getServiceCost(services) {
    return new Promise((resolve, reject) => {
        console.log(`Calculate the service cost of ${services}.`);
        setTimeout(() => {
            resolve(services.length * 100);
        }, 2 * 1000);
    });
}

```

The following uses the promises to serialize the sequences:

```js
getUser(100)
    .then(getServices)
    .then(getServiceCost)
    .then(console.log);

// Output
// 

```

- Get the user from the database.
- Get the services of admin from the API.
- Calculate the service cost of Email,VPN,CDN.

300

Code language: JavaScript (javascript)

ðŸ“ Note that ES2017 introduced the async/await that helps you write code that is cleaner than using the promise chaining technique.











> âš ï¸ Note: This content is for educational and personal reference purposes only.
> The original source is shown at the top of the document.
>
> All rights and copyrights belong to their respective owners.